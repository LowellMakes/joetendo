#!/usr/bin/env python3

import datetime
import json
import os
from pathlib import Path
import shlex
import select
import signal
import subprocess
import sys
import time
import logging
from logging.handlers import SysLogHandler

import requests
import vdf


LOG = logging.getLogger('vent')


def ex(*args, check=True, capture_output=False):
    cmd = " ".join(shlex.quote(arg) for arg in args)
    LOG.debug("exec> %s", cmd)
    try:
        result = subprocess.run(args, check=check, capture_output=capture_output)
        return result
    except subprocess.CalledProcessError:
        LOG.exception("subprocess failed")
        raise


def mklink(source, dest):
    ex("ln", "-f", "-s", dest, source)


def switch_keymap(active_link, default_link, keymap):
    try:
        ex("systemctl", "is-active", "--quiet", "keyd")
    except subprocess.CalledProcessError:
        LOG.error("keyd is not running! What happened to it?")
        raise

    mklink(active_link, keymap)

    try:
        ex("keyd", "reload")
    except subprocess.CalledProcessError:
        LOG.error("keyd reload failed! Is there an error in the keyd configuration file?")

        try:
            if default_link != keymap:
                switch_keymap(active_link, default_link, default_link)
        except Exception:
            LOG.exception("Nested exception while trying to restore default keymap in exception handler...!")

        raise


def get_info(appID):
    ret = ex("steamcmd", "+app_info_print", appID, "+exit", capture_output=True)
    output = ret.stdout.decode()

    index = output.find(f'"{appID}"')
    if index == -1:
        LOG.error("Could not parse steamcmd output, start of VDF metadata could not be found")
        LOG.debug(output)
        raise Exception("Could not identify the start of VDF metadata")

    output = output[index:]
    index = output.find("Unloading Steam API")
    if index != -1:
        output = output[:index]
    info = vdf.loads(output)

    return info[appID]


def download_and_store(url, filename):
    if os.path.exists(filename):
        return

    try:
        rsp = requests.get(url)
        if rsp.status_code == 200:
            with open(filename, "wb") as outfile:
                outfile.write(rsp.content)
    except requests.ConnectionError:
        LOG.warning("ConnectionError fetching '%s'", url)


def get_images(appID, cachedir):
    libimg = os.path.join(cachedir, f"library_{appID}.jpg")
    url = f"https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/{appID}/library_600x900_2x.jpg"
    download_and_store(url, libimg)

    bgimg = os.path.join(cachedir, f"bg_{appID}.jpg")
    url = f"https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/{appID}/page_bg_raw.jpg"
    download_and_store(url, bgimg)


def get_executable(info):
    for execinfo in info['config']['launch'].values():
        if execinfo.get('config', {}).get('oslist', '') == 'linux':
            executable = execinfo['executable']
            if executable.startswith("./"):
                executable = executable[2:]
            return executable

    for execinfo in info['config']['launch'].values():
        if execinfo.get('config', {}).get('oslist', None) in ('windows', None):
            return execinfo['executable']

    raise Exception("Couldn't find a suitable executable to run this game ...?")


def load_or_fetch_info(appID, cachedir):
    target = os.path.join(cachedir, f"{appID}.json")

    if os.path.exists(target):
        with open(target, "r", encoding='UTF8') as infile:
            info = json.load(infile)
    else:
        info = get_info(appID)
        with open(target, "w", encoding='UTF8') as outfile:
            json.dump(info, outfile, indent=2)

    get_images(appID, cachedir)

    return info


def xfconf_query(channel, prop, value=None):
    if value:
        ex(
            "xfconf-query",
            "--create",
            "--type", "string",
            "-c", channel,
            "-p", prop,
            "-s", value,
        )
    else:
        ex(
            "xfconf-query",
            "-c", channel,
            "-p", prop,
            "-r",
        )


def remove_splash():
    xfconf_query("xfce4-terminal", "/background-image-file")
    xfconf_query("xfce4-terminal", "/background-mode")
    xfconf_query("xfce4-terminal", "/background-image-style")


def do_configure_splash(img):
    xfconf_query("xfce4-terminal", "/font-name", "Monospace Bold 20")
    if img:
        xfconf_query("xfce4-terminal", "/background-image-file", img)
        xfconf_query("xfce4-terminal", "/background-mode", "TERMINAL_BACKGROUND_IMAGE")
        xfconf_query("xfce4-terminal", "/background-image-style", "TERMINAL_BACKGROUND_STYLE_SCALED")
    else:
        remove_splash()


def configure_splash(img):
    try:
        do_configure_splash(img)
    except FileNotFoundError:
        LOG.warning("Could not change terminal background. Is xfconf-query installed?")


def launch_wait(appID, rootdir):
    subprocess.run("clear", check=False, shell=True)
    cachedir = os.path.join(rootdir, "cache/")
    os.makedirs(cachedir, exist_ok=True)

    info = load_or_fetch_info(appID, cachedir)
    executable = get_executable(info)
    game = info.get('common', {}).get('name', '?????')

    img = None
    bgimg = os.path.join(cachedir, f"bg_{appID}.jpg")
    libimg = os.path.join(cachedir, f"library_{appID}.jpg")
    if os.path.exists(bgimg):
        img = bgimg
    elif os.path.exists(libimg):
        img = libimg
    configure_splash(img)

    LOG.info(
        "Launching appID=%s; game='%s'; executable='%s';",
        appID, game, executable
    )

    print(f"Launching {game} ... ..", end='')
    sys.stdout.flush()

    ex("steam", f"steam://rungameid/{appID}")
    LOG.debug("Waiting for executable '%s'", executable)

    pid = None
    for i in range(60):
        ret = subprocess.run(
            f"ps ax -o pid,comm | grep -i {executable}",
            shell=True,
            capture_output=True,
            check=False,
        )
        if ret.returncode:
            print(f"\b\b{60-i:2d}", end='')
            sys.stdout.flush()
            time.sleep(1)
            continue

        pid = int(ret.stdout.decode().strip().split(" ")[0])
        LOG.debug(
            "Executable running: appID=%s; game='%s'; executable='%s'; pid=%s",
            appID,
            game,
            executable,
            pid,
        )
        break
    else:
        print("")
        LOG.error(
            "Timed out waiting for appID=%s; game='%s'; executable='%s'",
            appID,
            game,
            executable,
        )
        exc = Exception(
            f"Timed out waiting for {appID=} {game=} {executable=}"
        )
        exc.add_note(
            "System may be in an unusable state. "
            "Consider using the reset kill switch?"
        )
        raise exc

    print("")
    print("Game now running! Please enjoy =^_^=")

    pidfd = os.pidfd_open(pid)
    running = True

    def handler(_sig, _frame):
        LOG.debug("SIGTERM received from exit button")
        LOG.debug("Forwarding SIGTERM to game process")
        signal.pidfd_send_signal(pidfd, signal.SIGTERM)

    signal.signal(signal.SIGTERM, handler)

    while True:
        ret = select.select([pidfd], [], [])
        running = False
        LOG.debug(
            "appID=%s; game='%s'; executable='%s'; pid=%s closed, exiting vent launcher",
            appID,
            game,
            executable,
            pid,
        )
        LOG.debug("ret=%s", str(ret))
        print("Game closed, returning you to the menu (｡･ω･｡)ﾉ♡")
        break


def do_launch(active_link, keymap, appID, steam_root, default_map):
    switch_keymap(str(active_link), str(default_map), str(keymap))
    try:
        launch_wait(appID, str(steam_root))
    finally:
        switch_keymap(str(active_link), str(default_map), str(default_map))
        remove_splash()


def do_main():
    user = os.environ.get("SUDO_USER")
    if not user:
        user = os.environ.get("USER")
    if not user:
        # TODO: use 'whoami'?
        raise Exception("Failed to determine who is running this script. Who are you?")

    home = Path(os.path.expanduser(f"~{user}"))
    rp_root = home.joinpath("RetroPie")
    steam_root = rp_root.joinpath("steam")
    keymap_dir = steam_root.joinpath("keymaps")
    active_link = keymap_dir.joinpath("active.conf")
    default_map = keymap_dir.joinpath("default.conf")

    os.makedirs(keymap_dir, exist_ok=True)

    if len(sys.argv) > 1:
        appID = sys.argv[1]
        keymap = keymap_dir.joinpath(f"{appID}.conf")

        LOG.debug("> vent %s", appID)
        LOG.debug("    steam_root=%s", steam_root)
        LOG.debug("    keymap=%s", keymap)
        LOG.debug("    active_link=%s", active_link)
        LOG.debug("    default_map=%s", default_map)
        LOG.debug("    appID=%s", appID)

        do_launch(active_link, keymap, appID, steam_root, default_map)


def configure_logging():
    address = ''
    if os.path.exists('/dev/log'):
        address = '/dev/log'
    elif os.path.exists('/var/run/syslog'):
        address = '/var/run/syslog'

    if address:
        syslog = SysLogHandler(address=address)
    else:
        syslog = SysLogHandler()

    syslog.setLevel(logging.DEBUG)
    syslog.setFormatter(
        logging.Formatter("%(name)s: %(message)s")
    )

    LOG.setLevel(logging.DEBUG)
    LOG.addHandler(syslog)


def main():
    configure_logging()

    try:
        do_main()
    except Exception as exc:
        LOG.exception("Unhandled exception in main()")
        print("""
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⠶⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⡿⠃⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣘⣿⡧⠤⠤⠤⠖⠛⠋⠉⠙⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⡴⠚⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢯⠙⠦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⡤⢤⣴⣞⣹⡿⠶⣶⠀⠀⠀⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠈⠛⢦⣀⣀⣴⠟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢼⠁⢹⠁⣽⠏⠀⣠⣤⡴⠃⠀⠀⠀⣼⡀⠀⠀⠀⣠⠀⣤⣄⠀⠀⢸⠀⠀⠀⠀⠀⠓⢾⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⡴⣶⡶⣿⣇⠟⠀⠉⠀⢰⠏⠀⣤⣀⠀⠀⣸⠻⣷⠀⠀⣰⣿⣴⡯⠊⠀⢀⣿⣰⡄⠀⠶⢼⡄⠀⠙⡄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡴⠛⣉⣠⣾⣿⡇⠞⠃⠀⠀⠀⠀⢾⡆⢰⣿⠁⢀⡼⠣⢤⣿⣤⠞⠁⢹⣯⣧⠀⠀⡼⠉⢿⣧⠀⠀⠀⢻⡄⠀⢹⡄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⣾⣋⣴⣶⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠘⣷⣾⣧⡴⠋⢀⡴⠚⠛⠛⢶⡦⣼⣿⣿⣀⡾⠁⠀⠘⣿⣆⠀⠀⠘⡇⠀⠀⢧⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⢹⣿⡃⠀⠀⠘⣆⠚⢉⡷⠀⢱⡄⠙⣿⡿⠁⢤⣤⣰⣿⣿⠃⠀⠀⣿⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠻⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⣾⣿⡇⠀⠀⠀⠉⠙⢉⣥⠴⠚⠀⠀⠘⢧⠀⢸⢧⣼⣿⣿⡇⠀⠀⣾⠀⠀⢸⣽⣆⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⡟⠀⠀⠀⠀⠀⠀⢀⣼⠏⣿⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⠿⢏⣿⡇⠀⣰⣯⣴⠀⢸⠀⠙⠧⠀⠀⠀⠀
⠀⠀⠀⠐⢤⡀⠀⠀⠀⠀⠀⠀⠘⢛⠟⠀⠀⠀⠀⠀⢀⣰⣿⠅⠀⠙⣿⠳⠤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣺⠏⣇⣰⡟⣿⣿⣴⡟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠉⠢⡀⠀⠀⠀⠀⡰⠋⠀⠀⠀⠀⠀⢀⣾⡿⠁⠀⠀⠀⠸⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⢀⣿⢏⣼⢯⣿⡟⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⢀⡞⠁⠀⠀⠀⠀⠀⢀⣾⣿⣷⣠⠀⠀⠀⢸⡿⠀⠀⣖⠓⠒⠲⠤⠤⢄⣀⣀⠀⠀⠀⠀⢸⣿⠈⣿⡿⢡⣞⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣨⠏⠀⠀⠀⠀⠀⠀⢀⡞⣉⣈⢻⣿⣷⣤⣄⣼⡇⠀⠀⠙⠋⠉⠉⠉⠓⠒⠲⢭⣽⣲⣆⠀⣼⣿⠀⢿⡇⠀⠈⠓⢤⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⢀⡾⠋⠉⠉⠉⠛⢿⣿⣿⣿⡟⢶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⣩⡾⠟⠉⠀⢸⣷⡀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀
⣆⡀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⢀⣾⠀⣀⡀⠀⠀⠀⠈⠻⣿⣿⡛⠲⢭⣗⠦⣤⣀⠀⣀⣠⣤⣴⣺⣿⣏⡀⡀⠀⢀⣴⣿⣷⡄⠀⡀⠀⠀⠙⢦⡀⠀⠀⠀
⠀⠙⠳⢄⡀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⡼⠉⠉⠲⢯⠑⠆⠀⠀⠀⠙⣿⣷⡀⠀⠈⠉⠻⢿⣿⣝⡻⣿⣿⣷⣄⠙⠿⢷⡶⠟⠙⣇⡙⢮⣀⠘⠲⢄⡀⠀⠙⣆⠀⠀
⠀⠀⠀⠀⠙⠢⡾⠀⠀⠀⠀⠀⠀⠀⡼⠃⠀⠀⠀⠈⢳⠀⠀⠀⠀⠀⢹⣿⣇⢀⣠⠤⠚⣿⣿⣿⣿⣶⣭⣿⣿⣧⡀⠀⠀⠀⠀⠸⣽⡀⠈⠉⠛⠓⠒⠂⠀⠘⣧⠀
⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠇⠀⠀⠀⠀⢸⣿⣿⣿⡅⠀⣼⡏⢻⣏⠻⣷⣍⡙⠛⣿⣿⡆⠀⠀⠀⠀⢻⡇⠀⠀⠀⠀⠀⠀⠀⠈⢸⡆
⠀⠀⠀⠀⡀⠒⠷⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣴⣯⣸⠀⠀⠀⢀⣸⣿⣿⣿⢻⡴⣿⣅⣸⣿⡄⠈⠛⠿⣾⡿⣿⡿⣆⢀⠀⠀⠘⣿⠀⠀⠀⠀⠀⢀⣀⡴⠚⠁
⠀⠀⠀⠀⠙⠢⣄⡈⠉⠙⢷⡒⠒⠛⠻⣯⣭⣭⡿⢻⠟⠁⠀⠀⠠⣾⣿⣿⣿⣿⣄⡻⣬⣿⣿⣿⣦⣤⣤⣤⣤⣤⣘⣷⡘⣿⠀⠀⣴⡗⠒⠒⠒⠉⠉⠉⠁⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠙⢷⡀⠀⠙⠶⢤⣀⡀⠙⠦⣄⡀⠀⠀⣀⣀⣴⣿⣿⣿⣿⣿⣿⣷⣦⣦⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣷⠾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⣀⠀⠀⠀⠈⠙⠲⠤⣍⣉⠉⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡂⠰⣄⠀⠀⠀⠲⢤⣀⡀⠉⠉⠒⢢⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠬⠵⠤⠄⣀⣀⣘⣚⣶⠤⠒⠉⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠈⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠁⠀⠀⠀⠀⠀⠘⣷⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠈⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡏⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠘⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠤⠤⠤⠤⠤⠤⠤⠤⢀⣀⡠⢿⣮⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠘⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⠤⠖⠂⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡴⠞⠉⠀⠘⣿⢃⣿⣿⣿⣿⣿⣿⣿⠟⢿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠹⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢀⣀⠄⠀⠀⢀⣀⣀⣀⣀⠠⠀⢀⣀⣀⣠⢴⠿⠟⠋⠀⠀⠀⠀⠀⠀⢹⡇⢹⣿⣿⣿⣿⣿⣿⣤⣾⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⣧⠀⠀⠀⠀⠀⠀⠀⠀""")

        print("")
        print("Oww...!!")
        print(f"{type(exc).__name__}: {str(exc)}")
        print("")
        print(
            "This event has been logged. If you have admin access, type "
            "`journalctl --identifier=vent --since=today` to review the logs."
        )
        print("")
        print(
            "Please report this failure on the Arcade gaming basecamp, "
            "or send a mail to gaming@lowellmakes.com."
        )
        print("Thank you, and sorry for the inconvenience!")
        print("")
        print("You may want to press the reset switch inside the control deck.")
        print("The control panel lifts up, and there's a pink box with a black button on it.")
        print("Push it to reset the system.")
        print("")

        now = datetime.datetime.now()
        later = now + datetime.timedelta(minutes=3)
        while datetime.datetime.now() < later:
            remaining = later - datetime.datetime.now()
            print("\r" + "Return to menu in " + str(remaining)[3:], end='')
        raise
    finally:
        print("")


if __name__ == '__main__':
    main()
